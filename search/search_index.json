{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Comprehensive ODM for MongoDB </p> <p> </p> <p>   Mongotoy is a comprehensive Object-Document Mapper (ODM) that streamlines interactions with MongoDB databases in    Python applications. Powered by Motor driver, Mongotoy seamlessly    integrates with MongoDB, offering a versatile toolkit for constructing high-performance applications. This integration   facilitates efficient communication with MongoDB databases, guaranteeing optimal scalability and responsiveness. With    Mongotoy, you can unlock the full potential of MongoDB's features. </p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Asynchronous Power: Mongotoy leverages the asynchronous paradigm of Python, enabling efficient management of I/O operations for optimal performance and responsiveness in applications.</p> </li> <li> <p>Based on Motor Driver: Mongotoy is built on top of the asynchronous Motor MongoDB driver, ensuring seamless integration with asynchronous Python applications.</p> </li> <li> <p>Schemaless Flexibility: With a schemaless design, Mongotoy empowers developers to work with MongoDB databases without rigid schemas, adapting to evolving data models effortlessly.</p> </li> <li> <p>Intuitive API: Mongotoy features an elegant and straightforward API facilitating common database operations.</p> </li> <li> <p>Flexible Configuration Options: Mongotoy offers extensive configuration options at both the database and  document levels, enabling fine-tuning of MongoDB interactions for optimal performance and reliability.</p> </li> <li> <p>Custom Data Types Support: Mongotoy simplifies handling of custom data types and allows defining new types through Data Mapper classes, enhancing data integrity and consistency.</p> </li> <li> <p>Object-Document Mapping: Simplifying MongoDB document manipulation, Mongotoy maps Python objects to MongoDB  documents seamlessly, enabling intuitive and object-oriented interactions.</p> </li> <li> <p>Document Serialization: Mongotoy supports serialization of documents into JSON, BSON, or Python dictionaries,  enabling seamless integration with different parts of an application stack.</p> </li> <li> <p>Document Inheritance Support: Mongotoy provides robust support for document inheritance, enabling the creation of hierarchical data models and promoting code reuse and maintainability.</p> </li> <li> <p>Python Type Hint Support: Mongotoy allows developers to define document fields using Python type hints,  enhancing code readability and enabling type checking.</p> </li> <li> <p>Relationship Management: Simplifying relationship management between documents, Mongotoy offers robust support for references and embedded documents, automating insertions, deletions, and updates.</p> </li> <li> <p>Automatic Operation Handling: Mongotoy automates insertion and deletion management, ensuring data integrity  and consistency across related documents.</p> </li> <li> <p>Query Building: Mongotoy provides a powerful query building interface for constructing complex queries using  Pythonic syntax.</p> </li> <li> <p>Index Management: Mongotoy simplifies the management of database indexes, optimizing query performance for  efficient data retrieval.</p> </li> <li> <p>Transactions: Supporting MongoDB transactions, Mongotoy ensures data consistency and atomicity across multiple operations within a single transactional context.</p> </li> <li> <p>Geospatial Data Support: Mongotoy offers robust support for geospatial data types, facilitating storage,  querying, and spatial analysis.</p> </li> <li> <p>Database Seeding Management: With built-in support for database seeding, Mongotoy streamlines the  initialization of databases with predefined data sets, enhancing developer productivity.</p> </li> <li> <p>Support for Capped Collections: Mongotoy natively supports capped collections in MongoDB, ideal for  scenarios requiring fixed-size, ordered datasets.</p> </li> <li> <p>Time Series Collections Management: Mongotoy provides robust support for managing time series data in  MongoDB, optimized for storing and querying time-stamped data points.</p> </li> <li> <p>GridFS File Handling: Mongotoy seamlessly integrates with MongoDB's GridFS storage system for efficient handling of large files, offering a high-level interface for file management within MongoDB.</p> </li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the Apache 2.0 license.</p>"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#installing","title":"Installing","text":"<p>To start using Mongotoy just run to install it:  <pre><code>pip install mongotoy\n</code></pre></p> <p>Or, if using poetry:</p> <pre><code>poetry add mongotoy\n</code></pre>"},{"location":"quick_start/#quick-start","title":"Quick Start","text":"<p>Let's get started with a minimal example by defining a document and performing CRUD(s) operations on the database.</p> <pre><code>import asyncio\nfrom mongotoy import Document, Engine\nimport datetime\n\n\nclass Person(Document):\n    name: str\n    last_name: str\n    dob: datetime.date\n\n\n# Create database engine\ndb = Engine('test-db')\n\n\nasync def main():\n    # Create a new Person instance\n    person = Person(\n        name='John',\n        last_name='Doe',\n        dob=datetime.date(1990, 12, 25)\n    )    \n\n    # Connect to the MongoDB database.md\n    await db.connect('mongodb://localhost:27017')\n\n    # Open a database session\n    async with db.session() as session:\n\n        # Save the person to the database\n        await session.save(person)\n\n        # Fetch all persons from database\n        async for c in session.objects(Person):\n            print(c.dump_dict())\n\n        # Update person dob\n        person.dob=datetime.date(1995, 10, 25)\n        await session.save(person)\n\n        # Delete person from database\n        await session.delete(person)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>This example demonstrates the usage of Mongotoy to interact with MongoDB databases in Python asynchronously.</p> <p>Firstly, it defines a Person document class using Mongotoy's Document base class, specifying fields such  as <code>name</code>, <code>last_name</code>, and <code>dob</code> (date of birth).</p> <p>Then, it creates a database engine using <code>Engine('test-db')</code>, indicating the name of the MongoDB database to connect to.</p> <p>Within the <code>main()</code> function:</p> <ol> <li>A new Person instance named person is created with some sample data.</li> <li>The script connects to the MongoDB database using <code>await db.connect('mongodb://localhost:27017')</code>.</li> <li>A database session is opened using <code>async with db.session() as session</code>.</li> <li>The person object is saved to the database using <code>await session.save(person)</code>.</li> <li>All Person objects are fetched from the database using <code>async for c in session.objects(Person)</code>, and their details are printed.</li> <li>The <code>dob</code> field of the person object is updated and the updated person object is saved back to the database.</li> <li>Finally, the person object is deleted from the database using <code>await session.delete(person)</code>.</li> </ol>"},{"location":"docs/data_types/","title":"Data Types","text":""},{"location":"docs/data_types/#supported-data-types","title":"Supported Data Types","text":"<p>Mongotoy supports a wide range of data types, encompassing both common built-in Python types and custom types  tailored to specific use cases. </p>"},{"location":"docs/data_types/#supported-built-in-types","title":"Supported built-in types","text":"<ul> <li><code>str</code></li> <li><code>bool</code></li> <li><code>bytes</code></li> <li><code>int</code></li> <li><code>float</code></li> <li><code>decimal.Decimal</code></li> <li><code>datetime.datetime</code></li> <li><code>datetime.date</code></li> <li><code>datetime.time</code></li> <li><code>uuid.UUID</code></li> </ul>"},{"location":"docs/data_types/#supported-sequence-types","title":"Supported sequence types","text":"<ul> <li><code>list</code></li> <li><code>tuple</code></li> <li><code>set</code></li> </ul>"},{"location":"docs/data_types/#supported-bson-types","title":"Supported bson types","text":"<ul> <li><code>bson.ObjectId</code></li> <li><code>bson.Int64</code></li> <li><code>bson.Decimal128</code></li> <li><code>bson.Regex</code></li> <li><code>bson.Code</code></li> </ul>"},{"location":"docs/data_types/#custom-types","title":"Custom types","text":"<ul> <li><code>mogotoy.types.IPv4</code>: Represents an IPv4 address.</li> <li><code>mogotoy.types.IPv6</code>: Represents an IPv6 address.</li> <li><code>mogotoy.types.Port</code>: Represents a port number.</li> <li><code>mogotoy.types.Mac</code>: Represents a MAC address.</li> <li><code>mogotoy.types.Phone</code>: Represents a phone number.</li> <li><code>mogotoy.types.Email</code>: Represents an email address.</li> <li><code>mogotoy.types.CardNumber</code>: Represents a credit card number.</li> <li><code>mogotoy.types.Ssn</code>: Represents a Social Security Number (SSN).</li> <li><code>mogotoy.types.Hashtag</code>: Represents a hashtag.</li> <li><code>mogotoy.types.Doi</code>: Represents a Digital Object Identifier (DOI).</li> <li><code>mogotoy.types.Url</code>: Represents a URL.</li> <li><code>mogotoy.types.Version</code>: Represents a Semantic Version Number.</li> <li><code>mogotoy.types.Point</code>: Represents a GEO-JSON Point.</li> <li><code>mogotoy.types.MultiPoint</code>: Represents a GEO-JSON MultiPoint.</li> <li><code>mogotoy.types.LineString</code>: Represents a GEO-JSON LineString.</li> <li><code>mogotoy.types.MultiLineString</code>: Represents a GEO-JSON MultiLineString.</li> <li><code>mogotoy.types.Polygon</code>: Represents a GEO-JSON Polygon.</li> <li><code>mogotoy.types.MultiPolygon</code>: Represents a GEO-JSON MultiPolygon.</li> <li><code>mogotoy.types.Json</code>: Represents a valid json data.</li> <li><code>mogotoy.types.Bson</code>: Represents a valid bson data.</li> <li><code>mogotoy.types.File</code>: Represents a Grid-FS object.</li> </ul> <p>You can effortlessly use these data types within your documents, and Mongotoy will take care of automatic field creation and validation.</p>"},{"location":"docs/data_types/#using-nullable-types","title":"Using nullable types","text":"<p>By default, Mongotoy does not permit <code>null</code> data. However, you can specify nullability using <code>typing.Optional</code>.  Below is an example of a Person document that allows <code>null</code> data:</p> <pre><code>import datetime\nfrom typing import Optional\nfrom mongotoy import Document\n\n\nclass Person(Document):\n    name: Optional[str]\n    age: Optional[int]\n    dob: Optional[datetime.datetime]\n</code></pre>"},{"location":"docs/data_types/#using-documents-types","title":"Using documents types","text":"<p>Mongotoy facilitates the integration of other documents as types within documents, offering a flexible approach  to defining complex data structures. This means you can use instances of other Mongotoy document classes as  attribute types within your own document classes. By incorporating related documents as types, you can establish  meaningful relationships between different data entities, enhancing the organization and clarity of your data model.  This feature enables you to design more comprehensive and interconnected schemas, reflecting the real-world  relationships between entities in your application domain.</p> <p>Note</p> <p>There are two types of documents: <code>mongotoy.Document</code> and <code>mongotoy.EmbeddedDocument</code>.  While you can use both types seamlessly in your application, it's essential to understand that Mongotoy employs  different approaches under the hood to handle them.</p> <p>When you specify a document field with a <code>mongotoy.EmbeddedDocument</code> base type, Mongotoy treats it as embedded data,  meaning that the document is stored directly within the parent document. On the other hand, when you use a <code>mongotoy.Document</code> base type, Mongotoy treats it as a reference to another collection. See references</p> <p>Here's an example of embedding an address within a person document:</p> <pre><code>import datetime\nfrom mongotoy import Document, EmbeddedDocument\n\nclass Address(EmbeddedDocument):\n    street: str\n    city: str\n    zipcode: int\n    country: str\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n    address: Address\n</code></pre> <p>Here's an example of referencing an address within a person document:</p> <pre><code>import datetime\nfrom mongotoy import Document\n\nclass Address(Document):\n    street: str\n    city: str\n    zipcode: int\n    country: str\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n    address: Address\n</code></pre> <p>Note</p> <p>The only difference is the base class of the <code>Address</code> document.</p>"},{"location":"docs/data_types/#forwarding-types","title":"Forwarding types","text":"<p>Mongotoy facilitates the utilization of document types as forward dependencies,  enabling the use of document types that may not have been created yet or are defined in different modules. This feature supports a self-referential document type as well.</p> <p>Here's an example demonstrating the use of a self-referential document type:</p> <pre><code>import datetime\nfrom mongotoy import Document, reference\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n    parent: 'Person' = reference()\n</code></pre> <p>In this example, the <code>Person</code> document references its own type in the <code>parent</code> field, allowing for self-referential  relationships within the document.</p> <p>Attention</p> <p>Using <code>mongotoy.reference(</code>) is essential for specifying the <code>parent</code> field as a reference, especially when dealing  with Forwarding Types. Mongotoy doesn't evaluate Forwarding Types during document creation to determine their type.  By default, it assumes they are embedded documents. Therefore, <code>mongotoy.reference()</code> ensures proper handling of the  field as a reference. See references.</p>"},{"location":"docs/database/","title":"Database","text":""},{"location":"docs/database/#engine","title":"Engine","text":"<p>The <code>Engine</code> class in Mongotoy serves as a versatile interface for managing MongoDB databases, providing a  comprehensive set of features to streamline database operations. With asynchronous support built-in, it efficiently  handles tasks like database connection, sessions, migrations, and seeding, ensuring seamless interactions.  You can customize database interactions by specifying options such as codec options, read preference,  read concern, and write concern, tailoring the functionality to specific requirements.</p> <p>The Engine class accepts the following params:</p> <ul> <li>database: The name of the MongoDB database.</li> <li>codec_options: The BSON codec options.</li> <li>read_preference: The read preference for the MongoDB client.</li> <li>read_concern: The read concern for the MongoDB client.</li> <li>write_concern: The written concern for the MongoDB client.</li> </ul> <p>The following example shows how to initialize the Engine <pre><code>import bson\nimport pymongo\nfrom pymongo.read_concern import ReadConcern\nfrom mongotoy import Engine\n\n# Create database engine\nengine = Engine(\n    database='my-test-db',\n    codec_options=bson.CodecOptions(uuid_representation=bson.JAVA_LEGACY),    \n    read_preference=pymongo.ReadPreference.PRIMARY,\n    read_concern=ReadConcern('majority'),\n    write_concern=pymongo.WriteConcern(w=2)\n)\n</code></pre></p> <p>This example initializes an <code>Engine</code> instance with specified configuration. It sets the target database to <code>my-test-db</code> and configures <code>codec_options</code> to use the Java Legacy UUID representation. Additionally, it specifies <code>read_preference</code> as primary , a <code>read_concern</code> of <code>majority</code>, and a <code>write_concern</code> with a <code>w=2</code>. Overall,  the setup ensures compatibility and consistency in database interactions.</p> <p>The <code>Engine</code> class offers convenient properties and methods for seamless access to various MongoDB components.  With properties like <code>.client</code>, <code>.database</code>, and methods like <code>.collection()</code> and <code>.gridfs()</code>, you can effortlessly  interact with the underlying MongoDB client, database collections, and GridFS buckets.</p> <pre><code># Access to an underlying client\nengine.client\n\n# Access to an underlying database\nengine.database\n\n# Get a collection named 'users'\nengine.collection('users')\n\n# Get a bucket named 'images'\nengine.gridfs('images')\n</code></pre>"},{"location":"docs/database/#database-connection","title":"Database connection","text":"<p>The <code>engine.connect()</code> function establishes a connection to the MongoDB server asynchronously. It accepts connection  arguments for AsyncIOMotorClient and  includes an optional parameter, <code>ping</code>, which determines whether to ping the server after establishing the connection.</p> <pre><code># Connect to a local db, and send ping command\nawait engine.connect('mongodb://localhost:27017', ping=True)\n</code></pre> <p>Attention</p> <p>Before accessing any features of the <code>Engine</code> class, ensure it is connected to the database using the <code>connect()</code> method. Failure to do so will result in a <code>mongotoy.errors.EngineError</code>.</p>"},{"location":"docs/database/#open-session","title":"Open session","text":"<p>To open a new database session, use the <code>engine.session()</code> function. The <code>Session</code> object supports context handling, enabling you to use it within a context; this ensures the proper starting/ending of the session.  See session</p>"},{"location":"docs/database/#execute-migration","title":"Execute migration","text":"<p>Migrations in Mongotoy cover a range of tasks essential for seamlessly transitioning your data structures into MongoDB. These tasks include migrating indexes, creating capped collections, and defining time series collections. This comprehensive support ensures that your data migration process is efficient and encompasses all necessary  configurations for optimal data management in MongoDB.</p> <p>To migrate a document, use the <code>engine.migrate()</code> or <code>engine.migrate_all()</code> functions as follows:</p> <pre><code># Open database session\nasync with engine.session() as session:\n\n    # Migrate single document\n    await engine.migrate(Person, session=session)\n\n    # Migrate many documents\n    await engine.migrate_all([Author, Book], session=session)\n</code></pre> <p>Note</p> <p>Migrations are only applied if the associated collection for the document does not already exist in the database.</p>"},{"location":"docs/database/#execute-seeding","title":"Execute seeding","text":"<p>Seeding in Mongotoy provides a convenient way to populate your database with initial data, ensuring that your  database is preloaded with the necessary information to kickstart your application or project. It allows you to  define and execute seeding functions that insert predefined data into your MongoDB collections, helping you streamline the setup process and accelerate development.</p> <p>To execute a seeding function, use the <code>engine.seeding()</code> or <code>engine.seeding_all()</code> functions as follows:</p> <pre><code>from mongotoy.db import Session\n\nasync def seeder_01(session: Session):\n    # Exec some data insertions here ...\n\nasync def seeder_02(session: Session):\n    # Exec some data insertions here ...\n\n# Open database session\nasync with engine.session() as session:\n\n    # Seed one function\n    await engine.seeding(seeder_01, session=session)\n\n    # Seed many functions\n    await engine.seeding_all([seeder_01, seeder_02], session=session)\n</code></pre> <p>Note</p> <p>Seeding functions are applied only once, regardless of how many times they are executed. They are registered in a  collection named <code>mongotoy.seeding</code>, ensuring that they are executed only once to prevent duplicate data seeding.</p>"},{"location":"docs/database/#session","title":"Session","text":"<p>The <code>Session</code> class in Mongotoy provides a context manager for managing MongoDB database operations within a  transaction-like context. It facilitates starting and ending MongoDB sessions, allowing for efficient handling  of database transactions. Additionally, it offers methods for managing transactions, accessing object managers for document classes, interacting with GridFS buckets, saving documents to the database, deleting documents,  and managing cascading deletes. Through its asynchronous support, it ensures smooth and streamlined database  operations, enhancing the overall efficiency of MongoDB interactions.</p> <p>The <code>Session</code> class provides properties for managing MongoDB sessions and database interactions.  These properties include:</p> <ul> <li> <p>engine: Represents the <code>Engine</code> associated with the session, enabling direct access to database operations and configurations.</p> </li> <li> <p>started: Indicates whether the session has been initialized, offering a boolean value to track session status.</p> </li> <li> <p>driver_session: Offers access to the underlying MongoDB driver session, facilitating low-level database  operations and transactions.</p> </li> </ul>"},{"location":"docs/database/#lifecycle","title":"Lifecycle","text":"<p>The <code>Session</code> class offers a flexible approach to managing its lifecycle. While it provides a context manager  interface for automatic lifecycle management, you can also control it manually using the <code>start()</code> and <code>end()</code> methods. Sessions must always be instantiated from an <code>Engine</code> instance using the <code>engine.session()</code> function.</p> <pre><code># Open db session with context\nasync with engine.session() as session:\n    # Exec session operations here ...\n\n\n# Open db session with no context\nsession = engine.session()\nawait session.start()\n# Exec session operations here ...\nawait session.end()\n</code></pre> <p>These examples showcase two methods of opening a database session with Mongotoy's Engine class. The first one uses  a context manager, ensuring proper session handling and cleanup after execution. The second method directly initializes a session without context management, requiring explicit invocation of methods for session initiation and termination.</p>"},{"location":"docs/database/#open-transaction","title":"Open transaction","text":"<p>To open a new database transaction, use the <code>session.transaction()</code> function. The <code>Transaction</code> object supports  context handling, enabling you to use it within a context; this ensures the proper commit/abort of the  transaction. See transaction</p>"},{"location":"docs/database/#objects","title":"Objects","text":"<p>The <code>objects()</code> method in the <code>Session</code> class facilitates the creation of an <code>mongotoy.db.Objects</code> instance, which allows  for querying documents of a specified type within the session context. It provides flexibility in querying documents  and supports deep dereferencing when needed. See objects</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Get objects for Person document\n    persons = session.objects(Person)\n\n    # Eexec operations over persons ...\n</code></pre>"},{"location":"docs/database/#files","title":"Files","text":"<p>The <code>fs()</code> method in the <code>Session</code> class facilitates seamless interaction with GridFS. With this method, you can efficiently manage file storage directly within the database, ensuring robust and scalable  file handling capabilities. See files</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Get fs bucket\n    files = session.fs()\n\n    # Eexec operations over files ...\n</code></pre>"},{"location":"docs/database/#saving-documents","title":"Saving documents","text":"<p>The <code>save()</code> and <code>save_all()</code> methods in the <code>Session</code> class enable the efficient persistence of MongoDB documents  into the associated database. By invoking these methods, you can seamlessly store individual documents or batches of  documents while ensuring data integrity and consistency. This functionality streamlines the process of data storage, enhancing the overall efficiency and reliability of database operations.</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Save a single person\n    await session.save(person_01)\n\n    # Save many persons\n    await session.save_all([person_01, person_02])\n</code></pre> <p>By default, the saving methods do not include saving references. However, you can enable this functionality by  <code>setting save_references=True</code>. This feature allows for the comprehensive storage of documents along with their associated references, enhancing the integrity and completeness of the data stored in the MongoDB database.</p>"},{"location":"docs/database/#deleting-documents","title":"Deleting documents","text":"<p>The <code>delete()</code> and <code>delete_all()</code> methods in the <code>Session</code> class facilitate the removal of documents from the MongoDB  database. These methods provide a convenient way to delete individual documents or multiple documents at once.  Additionally, they offer support for cascading deletion, allowing for the removal of associated documents as well. This ensures efficient and streamlined data management within MongoDB, empowering users to maintain data integrity and cleanliness effectively.</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Delete a single person\n    await session.delete(person_01)\n\n    # Delete many persons\n    await session.delete_all([person_01, person_02])\n</code></pre> <p>By default, the deletion methods do not remove associated references, but you can activate this functionality by  setting <code>delete_cascade=True</code>. This feature allows for the removal of related references along with the specified  documents, ensuring comprehensive data cleanup and management.</p>"},{"location":"docs/database/#transaction","title":"Transaction","text":"<p>The <code>Transaction</code> class encapsulates MongoDB transactions, ensuring the atomicity of operations within a session  context. It is initialized with a session object, providing access to the associated MongoDB session via the <code>session</code>  property. Upon initialization, the class starts the transaction using the provided session. The <code>commit()</code> method is  responsible for committing changes made during the transaction, while <code>abort()</code> discards changes and closes the  transaction. These methods handle exceptions to ensure proper transaction management. Additionally, the class supports context management.</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Handle transaction in context\n    async with session.transaction():\n        # Exec session operations inside transaction here ...\n\n    # Handle transaction manually\n    tx = session.transaction()\n    try:\n        # Exec transaction operations here ...\n    except:\n        await tx.abort()\n    else:\n        await tx.commit()\n</code></pre> <p>This example showcases transaction management within a database session. Transactions can be handled either  automatically within a context, ensuring commit or abort in case of errors, or manually, allowing for customized  error handling.</p>"},{"location":"docs/documents/","title":"Documents","text":""},{"location":"docs/documents/#defining-documents","title":"Defining documents","text":"<p>Defining documents in Mongotoy is straightforward. Simply inherit from <code>mongotoy.Document</code> class and define your class attributes similarly to how you would define a Python dataclass.  In this example, each class attribute represents a field in the database, and the class itself corresponds  to a collection:</p> <pre><code>import datetime\nfrom mongotoy import Document\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n</code></pre> <p>Attention</p> <p>When defining class attributes, it's crucial to specify their types. Mongotoy utilizes these type annotations  to generate fields accordingly. Attributes without type annotations will be ignored and treated as regular class fields.</p> <p>Note</p> <p>By default, Mongotoy does not require any field values to be specified during document creation, aligning with MongoDB's schemaless nature. Unspecified field values are set to <code>mongotoy.expressions.EmptyValue</code>, and Mongotoy  only validates the values of fields that have been explicitly specified. The exception to this rule is the <code>id</code> field, which must have at least one default value defined either through the <code>default</code> or <code>default_factory</code> properties.</p>"},{"location":"docs/documents/#the-collection-name","title":"The collection name","text":"<p>By default, Mongotoy pluralizes the lowercase class name to determine the collection name. So, in this  case, the collection name will be <code>persons</code>. </p> <p>Additionally, you can specify a custom collection name by defining the <code>__collection_name__</code> property within the class:</p> <pre><code>from mongotoy import Document\n\n\nclass Person(Document):\n    __collection_name__ = 'users'\n</code></pre>"},{"location":"docs/documents/#the-id-field","title":"The id field","text":"<p>In Mongotoy, the <code>id</code> field is essential in every document, acting as the primary key to ensure unique identification.  You can define the id field using the <code>mongotoy.field(id_field=True)</code> as explained in the  fields section. If you create a new document without explicitly specifying an <code>id</code> field, Mongotoy automatically  generates one and assigns a <code>bson.ObjectId</code> type to it. This unique identifier simplifies document management and  facilitates efficient querying within MongoDB collections.</p> <p>Note</p> <p>All classes derived from <code>mongotoy.Document</code> come with an <code>id</code> property, which provides access to the document's ID  field. To retrieve the ID field of a <code>Person</code> document, simply access it using <code>Person.id</code>. Similarly, to access the ID field value of a <code>Person</code> instance, use <code>person.id</code>.</p>"},{"location":"docs/documents/#configuration","title":"Configuration","text":"<p>Mongotoy offers document-level configuration for various settings, including indexes, capped collection options,  timeseries collection options, codec options, read preference, read concern, write concern, and additional  MongoDB collection options.</p> <p>Configuration params:</p> <ul> <li>indexes: List of indexes for the document.</li> <li>capped: Indicates if the collection is capped (default is False).</li> <li>capped_size: The maximum size of the capped collection in bytes (default is 16 MB).</li> <li>capped_max: The maximum number of documents allowed in a capped collection (default is None).</li> <li>timeseries_field: The field name to use as the time field for timeseries collections (default is None).</li> <li>timeseries_meta_field: The field name for metadata in timeseries collections (default is None).</li> <li>timeseries_granularity: The granularity of time intervals.</li> <li>timeseries_expire_after_seconds: The expiration time for documents in a timeseries collection, in seconds.</li> <li>codec_options: The BSON codec options (default is None).</li> <li>read_preference: The read preference for the document (default is None).</li> <li>read_concern: The read concern for the document (default is None).</li> <li>write_concern: The write concern for the document (default is None).</li> <li>extra_options: Extra options for the collection creation (default is an empty dictionary).</li> </ul> <p>These configurations exclusively pertain to the document collection level and do not extend to other collections within  the database. To specify settings, you use the <code>document_config</code> class attribute in your document definition.</p> <pre><code>from mongotoy import Document\nfrom mongotoy.documents import DocumentConfig\n\n\nclass Person(Document):\n    document_config = DocumentConfig(capped_collection=True)\n</code></pre>"},{"location":"docs/documents/#embedded-documents","title":"Embedded documents","text":"<p>An embedded document serves as a container for defining complex object types that are nested within other  documents. Unlike documents, embedded documents do not represent individual collections in the database.  Instead, they are used to encapsulate related data fields within a parent document, allowing for more structured and  organized data models.</p> <p>Mongotoy supports the creation of embedded documents by inheriting from <code>mongotoy.EmbeddedDocument</code> and defining your  class attributes in a manner similar to how you would define a Document. Here's a quick example:</p> <pre><code>from mongotoy import EmbeddedDocument\n\n\nclass Address(EmbeddedDocument):\n    street: str\n    city: str\n    zipcode: int\n    country: str\n</code></pre>"},{"location":"docs/documents/#dumping-documents","title":"Dumping documents","text":"<p>Mongotoy simplifies the process of exporting document data by offering three distinct methods:  <code>dump_dict</code>, <code>dump_json</code>, and <code>dump_bson</code>. These three methods offer flexibility, allowing you to choose the appropriate format based on needs and integration requirements.</p> <p>Note</p> <p>The <code>dump_json</code> and <code>dump_bson</code> methods only prepares data for compatibility with JSON and BSON formats respectively.  However, they don't perform serialization themselves, to fully serialize the data you'll need to use an  appropriate third-party library.</p>"},{"location":"docs/documents/#dict","title":"Dict","text":"<p>The <code>dump_dict</code> method converts document data into a Python dictionary format, facilitating integration with Python-based workflows and applications. It supports the following customization parameters to tailor the output  according to specific requirements.</p> <ul> <li>by_alias: Dumping by fields aliases. (default is False)</li> <li>exclude_empty: Exclude fields with empty values from the output. (default is False)</li> <li>exclude_null: Exclude fields with null values from the output. (default is False)</li> </ul>"},{"location":"docs/documents/#json","title":"Json","text":"<p>The <code>dump_json</code> method export the document data in a format compatible with JSON, facilitating interoperability with various systems and services supporting JSON data exchange. It supports the following customization parameters to tailor the output according to specific requirements.</p> <ul> <li>by_alias: Dumping by fields aliases. (default is False)</li> <li>exclude_null: Exclude fields with null values from the output. (default is False)</li> </ul>"},{"location":"docs/documents/#bson","title":"Bson","text":"<p>The <code>dump_bson</code> method export the document data in a format compatible with BSON for seamless interaction  with MongoDB database. It supports the following customization parameters to tailor the output  according to specific requirements.</p> <ul> <li>by_alias: Dumping by fields aliases. (default is True)</li> <li>exclude_null: Exclude fields with null values from the output. (default is False)</li> </ul> <p>Note</p> <p>The <code>dump_json</code> and <code>dump_bson</code> methods exclude empty values from the output, unlike <code>dump_dict</code>, which includes  them optionally.</p> <p>Through these versatile dumping methods, Mongotoy empowers you to work with document data in various formats, catering to diverse data processing and integration requirements. Whether it's within Python environments,  interoperating with JSON-compatible systems, or interacting with MongoDB databases, Mongotoy provides the  flexibility and compatibility needed for efficient data management and integration.</p>"},{"location":"docs/fields/","title":"Fields","text":""},{"location":"docs/fields/#fields","title":"Fields","text":"<p>Mongotoy not only generates fields based on types but also provides options for customization such as  aliases, indexing, uniqueness, and default values using the <code>mongotoy.field()</code> function. This enables you to define fields with specific properties tailored to the application needs, offering enhanced control and flexibility in document definition.</p>"},{"location":"docs/fields/#customization-parameters","title":"Customization parameters","text":"<p>The <code>mongotoy.field()</code> function accepts the following parameters:</p> <ul> <li>alias: Alias for the field. Defaults to None.</li> <li>id_field: Indicates if the field is an ID field. Defaults to False.</li> <li>default: Default value for the field. Defaults to <code>mongotoy.expresions.EmptyValue</code>.</li> <li>default_factory: Factory function for generating default values. Defaults to None.</li> <li>index: Type of index for the field. Defaults to None.</li> <li>sparse: Whether the index should be sparse. Defaults to False.</li> <li>unique: Whether the index should be unique. Defaults to False.</li> </ul> <p>Here's an example that showcases the customization of fields in Mongotoy documents.  Each field in the <code>Person</code> class utilizes the <code>mongotoy.field()</code> function for customization.</p> <pre><code>import uuid\nimport pymongo\nimport datetime\nfrom mongotoy import Document, field\n\n\nclass Person(Document):\n    code: str = field(id_field=True, default_factory=lambda: uuid.uuid4().hex)\n    name: str = field(index=pymongo.TEXT, unique=True)\n    age: int = field(index=pymongo.DESCENDING)\n    dob: datetime.datetime = field(default_factory=datetime.date.today)\n</code></pre>"},{"location":"docs/fields/#extra-configurations","title":"Extra configurations","text":"<p>The <code>mongotoy.field()</code> function accepts additional parameters for fine-tuning field creation and validation.  Certain data types support specific configuration parameters.</p>"},{"location":"docs/fields/#comparable-types","title":"Comparable types","text":"<p>Comparable types such as <code>int</code>, <code>float</code>, <code>decimal.Decimal</code>, <code>datetime.datetime</code>, <code>datetime.date</code> and <code>datetime.time</code> enable comparison operations between values of the same type. These types support various comparison configuration parameters to fine-tune how comparisons are conducted.</p> <ul> <li>lt (less than)</li> <li>lte (less than or equal to)</li> <li>gt (greater than)</li> <li>gte (greater than or equal to)</li> </ul>"},{"location":"docs/fields/#string-type","title":"String type","text":"<p>The <code>str</code> type supports these configuration parameters for customization:</p> <ul> <li>min_length: Specifies the minimum length allowed.</li> <li>max_length: Specifies the maximum length allowed.</li> <li>choices: Defines a list of valid value choices.</li> <li>regex: Defines a regular expression to validate.</li> </ul>"},{"location":"docs/fields/#sequence-types","title":"Sequence types","text":"<p>Sequence types such as <code>list</code>, <code>tuple</code> and <code>set</code> supports these configuration parameters for customization:</p> <ul> <li>min_items: Specifies the minimum items allowed.</li> <li>max_items: Specifies the maximum items allowed.</li> </ul> <p>The following example shows how to use extra configuration parameters:</p> <pre><code>from mongotoy import Document, field\n\n\nclass Person(Document):\n    name: str = field(max_length=128)\n    age: int = field(gte=21)\n    colors: list[str] = field(choices=['white', 'black', 'green'], max_items=2)\n</code></pre>"},{"location":"docs/files/","title":"Files","text":""},{"location":"docs/files/#bucket","title":"Bucket","text":"<p>The Bucket is a fundamental component for managing file storage within Mongotoy. Representing the default GridFS bucket named <code>fs</code>, it offers a robust interface for seamless file operations. With functionalities including file search,  uploads, existence checks, and access to revisions, the Bucket streamlines file management tasks. By ensuring  consistency, reliability, and efficiency in handling file storage, it enhances the overall file management experience within Mongotoy.</p>"},{"location":"docs/files/#getting-a-bucket","title":"Getting a bucket","text":"<p>Use the <code>session.fs()</code> method to obtain a Bucket object, which represents a  GridFS bucket named <code>fs</code>. </p> <pre><code># Open db session\nasync with engine.session() as session:\n    # Get a Bucket\n    fs = session.fs()\n</code></pre>"},{"location":"docs/files/#creating-files","title":"Creating files","text":"<p>To create a file, you can invoke the <code>create()</code> method in the Bucket. With support for parameters like source, metadata, and chunk size, this method provides flexibility and customization options, ensuring efficient file management.</p> <pre><code># Create an image file\nimage = await fs.create('profile.jpeg', src=open('profile.jpeg'))\n</code></pre>"},{"location":"docs/files/#search-revisions","title":"Search revisions","text":"<p>You can effortlessly retrieve all revisions associated with a specific file stored in the file system bucket through  the <code>revisions()</code> method in the Bucket. This method provides access to historical file versions, facilitating version  control and supporting comprehensive file analysis.</p> <pre><code># Get all revisions of profile.jpeg file\nrevisions = await fs.revisions(filename='profile.jpeg')\n</code></pre>"},{"location":"docs/files/#file-existence","title":"File existence","text":"<p>To verify the existence of files within the designated bucket, you can use the <code>exist()</code> method in the Bucket. This  method offers a straightforward approach to checking file presence within the bucket, enhancing file management  efficiency.</p> <pre><code># Check if profile.jpeg file exists\nexist = await fs.exist(filename='profile.jpeg')\n</code></pre> <p>Note</p> <p>As the Bucket class inherits from Objects, it inherits all functionalities for  filtering, sorting, and counting files.</p>"},{"location":"docs/files/#file","title":"File","text":"<p>Handling files in Mongotoy becomes effortless when you integrate the <code>mongotoy.types.File</code> into your document structure. This simple step allows you to create a field representing a GridFS object seamlessly. With the <code>mongotoy.types.File</code>, managing files within your Mongotoy documents becomes a breeze,  enabling smooth storage and retrieval processes. This integration enhances the usability and flexibility of Mongotoy  for you, empowering you to handle file-related operations with ease and confidence.</p> <pre><code>from mongotoy import Document\nfrom mongotoy.types import File\n\nclass Person(Document):\n    image: File\n</code></pre>"},{"location":"docs/files/#creating-revision","title":"Creating revision","text":"<p>In Mongotoy, files are capable of having multiple revisions or versions, ensuring flexibility and version control within your document storage. Creating a new revision of a file is a seamless process, as you can invoke the <code>create_revision()</code> method in a <code>File</code> object.</p> <pre><code># Open db session\nasync with engine.session() as session:\n    # Get a FsBucket\n    fs = session.fs()\n\n    # Create a new revision of person image\n    await person.image.create_revision(fs, src=open('profile2.jpeg'))\n</code></pre>"},{"location":"docs/files/#download-contents","title":"Download contents","text":"<p>To download the contents of files in Mongotoy, you can use the <code>download_to()</code> method available within a <code>File</code> object. This method streamlines the process, allowing you to retrieve the file's contents effortlessly.</p> <pre><code># Open db session\nasync with engine.session() as session:\n    # Get a FsBucket\n    fs = session.fs()\n\n    # Download person image\n    await person.image.download_to(fs, dest=open('profile3.jpeg'))\n</code></pre>"},{"location":"docs/files/#streaming-contents","title":"Streaming contents","text":"<p>To stream file contents in Mongotoy, you can use the <code>stream()</code> method provided within a <code>File</code> object. This method returns a <code>FieldStream</code> object, equipped with capabilities to seamlessly stream file contents. See streaming</p> <pre><code># Open db session\nasync with engine.session() as session:\n    # Get a FsBucket\n    fs = session.fs()\n\n    # Stream person image\n    stream = await person.image.stream(fs)\n</code></pre>"},{"location":"docs/files/#getting-a-revision","title":"Getting a revision","text":"<p>You can effortlessly download or stream any revision of a file by  indicating the <code>revision</code> parameter in the <code>download_to()</code> and <code>stream()</code> methods, respectively. This parameter,  represented by an integer value, denotes the relationship with the upload date of the revision.</p> <p>Here's how revision numbers are defined:</p> <ul> <li>0: Represents the original stored file.</li> <li>1: Denotes the first revision.</li> <li>2: Signifies the second revision.</li> <li>-2: Refers to the second most recent revision.</li> <li>-1: Indicates the most recent revision.</li> </ul> <pre><code>from io import BytesIO\n\ncontents = BytesIO()\n\n# Download the original revision\nawait person.image.download_to(fs, dest=contents)\n\n# Download first revision\nawait person.image.download_to(fs, dest=contents, revision=1)\n\n# Download the most recent revision\nawait person.image.download_to(fs, dest=contents, revision=-1)\n</code></pre>"},{"location":"docs/files/#delete-file","title":"Delete file","text":"<p>To delete a file from the database, you can invoke the <code>delete()</code> method available within a <code>File</code> object.  This straightforward method facilitates the deletion process, ensuring efficient management of your database fields.</p> <pre><code># Open db session\nasync with engine.session() as session:\n    # Get a FsBucket\n    fs = session.fs()\n\n    # Delete person image\n    await person.image.delete(fs)\n</code></pre> <p>Note</p> <p>When deleting documents, file fields within them do not trigger file deletion automatically. To remove files  associated with documents, manual deletion is required using the <code>delete()</code> method within the <code>File</code> object.</p>"},{"location":"docs/files/#streaming","title":"Streaming","text":"<p>Streaming in Mongotoy enables efficient data retrieval from GridFS, facilitating seamless access to large files stored in the database and improving performance by minimizing latency. By allowing data to be read and processed in chunks, streaming reduces memory usage and enhances scalability. With built-in support for streaming in <code>File</code> objects, you can integrate streaming functionality into tasks such as file uploads,  downloads, and data processing. Overall, streaming in Mongotoy empowers users to effectively work with large datasets  while optimizing performance and resource utilization.</p> <p>The Streams in Mongotoy offers the following methods for efficient file data retrieval:</p> <ul> <li> <p>read(size = -1): Read data from the file, allowing you to specify the number of bytes to read or read until  the end of the file if not specified.</p> </li> <li> <p>readchunk(): Read a chunk of data from the file, providing you with chunk-based data retrieval.</p> </li> <li> <p>readline(size = -1): Read a line from the file, with the option to specify the maximum number of bytes to read or read until the end of the line if not specified.</p> </li> <li> <p>seek(pos, whence = os.SEEK_SET): Moves the file pointer to a specified position, with options to  specify the reference point for the seek operation.</p> </li> <li> <p>seekable(): Checks if the file is seekable, returning True if the file is seekable and False otherwise.</p> </li> <li> <p>tell(): Returns the current position of the file pointer, providing users with information about the current  reading position within the file.</p> </li> <li> <p>close(): Closes the stream, ensuring proper resource management and cleanup.</p> </li> </ul> <pre><code># Get the stream\nstream = await person.image.stream(fs)\n\n# Read all contents\ncontents = await stream.read()\n\n# Seek to position 0\nstream.seek(0)\n\n# Read by chunks\nfor _ in range(person.image.chunks):\n    chunk = await stream.readchunk()\n\n# Close stream\nstream.close()\n</code></pre>"},{"location":"docs/migrations/","title":"Migrations","text":""},{"location":"docs/objects/","title":"Objects","text":""},{"location":"docs/objects/#objects","title":"Objects","text":"<p>The <code>Objects</code> class in Mongotoy facilitates querying documents from a MongoDB database, offering a variety of methods  for filtering, sorting, limiting, and executing queries asynchronously. It is initialized with the document class associated with the query set, a session object for database operations, and an optional depth for dereferencing  referenced documents. Key features include filtering, sorting, skipping, and limiting. Asynchronous and synchronous iteration over the result set is supported, with methods to fetch all documents, retrieve a single document, fetch  a document by its identifier, and count the number of documents.</p> <p><code>Objects</code> instances are created by initializing them with a session  object. For instance:</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Create objects from a Person document\n    persons = session.objects(Person)\n</code></pre>"},{"location":"docs/objects/#filtering-documents","title":"Filtering documents","text":"<p>The <code>filter()</code> method in the <code>Objects</code> class allows users to specify filter conditions for database queries, facilitating precise data retrieval based on user-defined criteria. It accepts a variable number of filter expressions and keyword  arguments. These conditions are then combined with existing filters using logical <code>AND</code> operations, ensuring that the  resulting query set accurately reflects the specified filtering criteria.  See querying expressions</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Get persons older than 21 years\n    older_persons = session.objects(Person).filter(Person.age &gt; 21)\n\n    # Get persons from USA\n    usa_persons = session.objects(Person).filter(address__country__eq='USA')\n</code></pre> <p>Note</p> <p>The <code>filter()</code> method in the <code>Objects</code> class accepts all querying forms described in querying expressions </p>"},{"location":"docs/objects/#sorting-documents","title":"Sorting documents","text":"<p>The <code>sort()</code> method in the <code>Objects</code> class allows users to specify sorting conditions for database queries, enabling  ordered data retrieval based on user-defined criteria. It accepts multiple sort expressions as parameters and adds them to the query set, ensuring that the result set is sorted accordingly. See filtering expressions</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Order persons by dob descending\n    persons = session.objects(Person).sort(-Person.dob)\n</code></pre> <p>Note</p> <p>The <code>sort()</code> method in the <code>Objects</code> class accepts all sorting forms described in sorting expressions </p>"},{"location":"docs/objects/#limiting-documents","title":"Limiting documents","text":"<p>With the <code>skip()</code> and <code>limit()</code> functions in the <code>Objects</code> class, you can precisely control the pagination of query results. By using <code>skip()</code>, you can specify the number of documents to skip in the result set, allowing you to bypass a certain  number of documents before retrieving results. Conversely, the <code>limit()</code> function lets you define the maximum number of  documents to return in the result set, ensuring that only a specified number of documents are included in the output.  These functions provide you with flexibility in navigating through large datasets and retrieving only the necessary information, contributing to efficient data retrieval and processing.</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Skip 1st person and obtain next 5 persons\n    persons = session.objects(Person).skip(1).limit(5)\n</code></pre>"},{"location":"docs/objects/#dereferencing-documents","title":"Dereferencing documents","text":"<p>The <code>dereference_deep</code> property in the Objects class sets the depth of dereferencing for related documents during query execution. This allows fine-grained control over how deeply nested documents are retrieved from the database. A value  of <code>-1</code> indicates full dereferencing, <code>0</code> means no dereferencing (default behavior), and positive values specify  the number of levels to dereference. This property enhances flexibility in handling intricate data structures.</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # No dereferencing `dereference_deep=0` by default\n    persons = session.objects(Person)\n\n    # Dereferencing 1 level\n    persons = session.objects(Person, dereference_deep=1)\n\n    # Dereferencing all levels\n    persons = session.objects(Person, dereference_deep=-1)\n</code></pre>"},{"location":"docs/objects/#iterating-documents","title":"Iterating documents","text":"<p>The <code>Objects</code> class enables asynchronous and synchronous iteration over the result set of a database query. It executes  the query asynchronously or synchronously, yielding parsed document instances one by one. Those functions are essential  for handling large datasets efficiently, as it allows you to iterate over query results without blocking the event loop. By leveraging the asynchronous and synchronous iteration, you can seamlessly process query results in an asynchronous or  synchronous manner.</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Iterate over all persons\n    async for person in session.objects(Person):\n        print(person)\n</code></pre>"},{"location":"docs/objects/#fetching-documents","title":"Fetching documents","text":"<p>In Mongotoy, you have several options for fetching documents. The Objects class offers the following methods for  retrieving data:</p> <ul> <li> <p>all(): Retrieves all documents in the result set. It returns a list of parsed document instances,  enabling comprehensive access to query results for further processing or display.</p> </li> <li> <p>one(): Retrieves a specific document from the result set. It returns a single-parsed document instance. Raise <code>mongotoy.errors.NoResultError()</code> if no result found.</p> </li> <li> <p>one_or_none(): Retrieves a specific document from the result set. It returns a single-parsed document instance or <code>None</code> if no result found.</p> </li> </ul> <p>These functions contribute to efficient data retrieval and manipulation by leveraging asynchronous or synchronous operations, ensuring responsiveness and scalability in handling database queries.</p> <pre><code># Open db session\nasync with engine.session() as session:\n    # Fetching all persons\n    persons = await session.objects(Person).all()\n\n    # Fetching one person\n    person = await session.objects(Person).one()\n</code></pre>"},{"location":"docs/objects/#counting-documents","title":"Counting documents","text":"<p>The <code>count()</code> function in the <code>Objects</code> class retrieves the total count of documents that match the specified query  criteria. This method executes an asynchronous operation to determine the number of documents in the result set. It  provides valuable insight into the size of the dataset returned by the query, enabling efficient management and  analysis of data.</p> <pre><code># Open db session\nasync with engine.session() as session:\n\n    # Counting all persons\n    persons_count = await session.objects(Person).count()\n</code></pre>"},{"location":"docs/objects/#querying-expressions","title":"Querying Expressions","text":"<p>In Mongotoy, you have a variety of options for crafting queries to suit your needs. You can opt for a Pythonic approach, using basic operands for simpler operations. Alternatively, you can leverage the Query class to  access a comprehensive range of supported operands. If you're familiar with Django's querying style, Mongotoy also  offers a similar syntax through Q function. Additionally, if you prefer to work with raw MongoDB queries, you have the flexibility to execute them directly through filter method. With these  diverse options, you can choose the querying method that best fits your requirements and preferences.</p> <p>You can construct queries by using Document fields along with Python operands and values, providing an intuitive  and Pythonic approach. This method allows you to express basic operations with ease, making it ideal for simple queries.</p> <p>Supported operand are:</p> <ul> <li><code>==</code>: Represents equality comparison of the field.</li> <li><code>!=</code>: Represents inequality comparison of the field.</li> <li><code>&gt;</code>: Represents greater-than comparison of the field.</li> <li><code>&gt;=</code>: Represents greater-than-or-equal-to comparison of the field.</li> <li><code>&lt;</code>: Represents less-than comparison of the field.</li> <li><code>&lt;=</code>: Represents less-than-or-equal-to comparison of the field.</li> </ul> <pre><code># Persons older than 21 years\nPerson.age &gt; 21\n\n# Persons from USA\nPerson.address.country == 'USA'\n</code></pre>"},{"location":"docs/objects/#logic-operands","title":"Logic operands","text":"<p>Mongotoy also supports logical operands such as <code>AND</code>, <code>OR</code>, and <code>NOT</code> to combine queries. These operators enable you to create more complex and sophisticated query expressions by joining multiple conditions together.</p> <p>Supported logic operand are:</p> <ul> <li><code>&amp;</code>: Represents the logical <code>AND</code> operation between two query expressions.</li> <li><code>|</code>: Represents the logical <code>OR</code> operation between two query expressions.</li> <li><code>~</code>: Represents the logical <code>NOT</code> operation on the query expression.</li> </ul> <pre><code># Persons older than 21 years and younger than 60 years\nPerson.age &gt; 21 &amp; Person.age &lt; 60\n\n# Non-USA persons\n~Person.address.country == 'USA'\n</code></pre> <p>When concatenating multiple queries with logical operands like <code>AND</code> or <code>OR</code>, you can use parentheses to enclose  related expressions, providing clearer grouping.</p> <pre><code># Persons older than 21 years and younger than 60 years, or persons from USA\n(Person.age &gt; 21 &amp; Person.age &lt; 60) | Person.address.country == 'USA'\n</code></pre> <p>Attention</p> <p>It's important to use parentheses correctly for expression grouping, as improper usage can lead to incorrect query expressions.</p>"},{"location":"docs/objects/#the-query-class","title":"The Query class","text":"<p>Mongotoy's <code>mongotoy.expressions.Query</code> class empowers you to construct MongoDB query expressions with flexibility.  It offers an array of methods for creating comparisons, enabling the crafting of complex queries. These methods serve as a convenient interface for generating specific query expressions, tailored precisely to your requirements.</p> <p>Supported methods are:</p> <ul> <li>Eq(field, value): Creates an equality query expression</li> <li>Ne(field, value): Creates a not-equal query expression</li> <li>Gt(field, value): Creates a greater-than query expression.</li> <li>Gte(field, value): Creates a greater-than-or-equal query expression.</li> <li>Lt(field, value): Creates a less-than query expression.</li> <li>Lte(field, value): Creates a less-than-or-equal query expression.</li> <li>In(field, value): Creates an 'in' query expression.</li> <li>Nin(field, value): Creates a 'not in' query expression.</li> <li>Regex(field, value): Creates a regex query expression.</li> </ul> <pre><code>from mongotoy.expressions import Query\n\n# Persons older than 21 years\nQuery.Gt(Person.age, 21)\n\n# Persons from USA\nQuery.Eq(Person.address.country, 'USA')\n\n# Non-USA persons\nQuery.Ne(Person.address.country, 'USA')\n\n# Persons older than 21 years and younger than 60 years, or persons from USA\n(Query.Gt(Person.age, 21) &amp; Query.Lt(Person.age, 60)) | Query.Eq(Person.address.country, 'USA')\n</code></pre> <p>Note</p> <p>All methods in the <code>Query</code> class support string values to specify fields.</p> <pre><code>from mongotoy.expressions import Query\n\n# Persons older than 21 years\nQuery.Gt('age', 21)\n</code></pre> <p>Attention</p> <p>To ensure accurate querying expressions, use the <code>alias</code> rather than the field <code>name</code> for fields with defined aliases.  Otherwise, querying operations might target nonexistent database fields, resulting in inaccuracies.</p>"},{"location":"docs/objects/#the-q-function","title":"The Q function","text":"<p>The <code>mongotoy.expressions.Q</code> function is a flexible constructor for creating complex query expressions in a database.  It accepts any number of keyword arguments, where each argument represents a field and its corresponding query  condition. </p> <p>The function parses each keyword, separating the field name from the operator, which is connected by double underscores. For instance, <code>name__eq</code> implies an equality check on the <code>name</code> field. The function then dynamically constructs a query by combining these conditions using logical <code>AND</code> operations. This allows users to build queries in a more readable and intuitive way, compared to manually constructing query strings.</p> <p>The <code>Q</code> function is particularly useful in scenarios where the query parameters are not known in advance and need to be constructed at runtime based on user input or other dynamic data sources. It encapsulates the complexity of query  construction, providing a clean and maintainable interface for building queries.</p> <pre><code>from mongotoy.expressions import Q\n\n# Persons older than 21 years\nQ(age__eq=21)\n\n# Persons from USA\nQ(address__country__eq='USA')\n\n# Non-USA persons\nQ(address__country__ne='USA')\n\n# Persons older than 21 years and younger than 60 years, or persons from USA\n(Q(age__gt=21) &amp; Q(age__lt=60)) | Q(address__country__eq='USA')\n</code></pre>"},{"location":"docs/objects/#sorting-expressions","title":"Sorting Expressions","text":"<p>In Mongotoy, you have a variety of options for crafting sorting expressions to suit your needs. You can opt for a  Pythonic approach, using basic operands for simpler operations. Alternatively, you can leverage the  Sort class.</p> <p>You can construct sorting expressions in Mongotoy by using document fields preceded with <code>-</code> for descending or <code>+</code> for ascending directions, offering an intuitive and Pythonic approach. This method simplifies the expression of basic  sorting criteria, making it ideal for straightforward sorting tasks.</p> <pre><code># Sort Persons descending by age\n-Person.age\n\n# Sort Persons ascending by age\n+Person.age\n</code></pre>"},{"location":"docs/objects/#multiple-sorting","title":"Multiple sorting","text":"<p>Mongotoy offers a seamless way to merge multiple sorting expressions using the <code>|</code> operator, providing you with a powerful tool for constructing sophisticated sorting criteria effortlessly.</p> <pre><code># Sort Persons descending by age and ascending by date of birth (dob)\n-Person.age | +Person.dob\n</code></pre>"},{"location":"docs/objects/#the-sort-class","title":"The Sort class","text":"<p>In Mongotoy, you can use the <code>mongotoy.expressions.Sort</code> class to effortlessly create versatile sorting expressions. With clear representations and handy utility methods at your disposal, generating ascending and descending sort  expressions becomes a breeze, streamlining your sorting operations.</p> <p>Supported methods are:</p> <ul> <li>Asc(*fields): Creates an ascending sort expressions</li> <li>Desc(*fields): Creates a descending sort expressions</li> </ul> <pre><code>from mongotoy.expressions import Sort\n\n# Sort Persons descending by age\nSort.Desc(Person.age)\n\n# Sort Persons ascending by age and date of birth\nSort.Asc(Person.age, Person.dob)\n\n# Sort Persons descending by age and ascending by date of birth (dob)\nSort.Desc(Person.age) | Sort.Asc(Person.dob)\n</code></pre> <p>Note</p> <p>All methods in the <code>Sort</code> class support string values to specify fields.</p> <pre><code>from mongotoy.expressions import Sort\n\n# Sort Persons descending by age and dob\nSort.Desc('age', 'dob')\n</code></pre> <p>Attention</p> <p>To ensure accurate sorting expressions, use the <code>alias</code> rather than the field <code>name</code> for fields with defined aliases.  Otherwise, sorting operations might target nonexistent database fields, resulting in inaccuracies.</p>"},{"location":"docs/references/","title":"References","text":""},{"location":"docs/references/#references","title":"References","text":"<p>Mongotoy simplifies the handling of references by automatically generating them when you use a <code>mongotoy.Document</code>  base type as a field in another document. This means that you don't need to manually manage references between documents.  Additionally, Mongotoy provides flexibility in configuring reference behavior through the <code>mongotoy.reference()</code>  function. With this function, you can customize how references are handled.</p>"},{"location":"docs/references/#customization-parameters","title":"Customization Parameters","text":"<p>The <code>mongotoy.reference()</code> function accepts the following parameters:</p> <ul> <li>ref_field: Name of the referenced field. Defaults to <code>id</code></li> <li>key_name: Key name for the reference. Defaults to None.</li> </ul> <p>Note</p> <p>If <code>key_name</code> isn't specified, Mongotoy automatically generates it by concatenating the name of the field that holds the reference value with the name of the referenced field. In the example below, if <code>key_name</code> is not specified explicitly, it will default to <code>parent_code</code>.</p> <p>Here's an example that showcases the customization of references in Mongotoy documents. </p> <pre><code>import datetime\nfrom mongotoy import Document, reference\n\n\nclass Person(Document):\n    code: str\n    name: str\n    age: int\n    dob: datetime.datetime\n    parent: 'Person' = reference(ref_field='code', key_name='p_code')\n</code></pre> <p>The <code>parent</code> field in the <code>Person</code> document class serves as a reference to another <code>Person</code> document,  denoting the individual's parent. Through the <code>mongotoy.reference()</code> function, the reference behavior is established based on the <code>code</code> field of the referenced document. In the database, the reference key is labeled as <code>p_code</code>.  This setup ensures that when a <code>Person</code> document is saved, the <code>code</code> value of the referenced <code>Person</code> document  stored in the <code>parent</code> field is also stored in the current document under the <code>p_code</code> key.</p> <p>Attention</p> <p>When defining references with forwarded types,  using <code>mongotoy.reference()</code> with a type that isn't derived from <code>mongotoy.Document</code>, or omitting <code>mongotoy.reference()</code>  when using a<code>mongotoy.Document</code> derived type, will result in a <code>mongotoy.errors.DocumentValidation</code> error during document instantiation.</p>"},{"location":"docs/seeding/","title":"Seeding","text":""},{"location":"docs/sync_mode/","title":"Sync Mode","text":""},{"location":"docs/sync_mode/#sync-mode","title":"Sync mode","text":"<p>The sync mode in Mongotoy enables the integration of asynchronous functionalities into synchronous workflows. It  offers features like enabling synchronous mode, wrapping asynchronous functions for synchronous execution, and  converting asynchronous generators into synchronous ones. These tools allow you to seamlessly incorporate Mongotoy's  asynchronous capabilities into synchronous applications, ensuring compatibility and flexibility across different  programming paradigms.</p> <p>To activate synchronous mode in your application, invoke the <code>mongotoy.enable_sync_mode()</code> function at the beginning of  you code. Then, to use Mongotoy synchronously, you can remove all <code>await</code> keywords from Mongotoy function calls related  to database operations. This straightforward approach allows for seamless integration of synchronous Mongotoy operations into your application.</p> <p>The <code>mongotoy.sync</code> module equips Mongotoy with essential utilities for seamlessly transitioning asynchronous  functionality into synchronous operations, offering the following functions:</p> <ul> <li> <p>enable_sync_mode(): Function to enable synchronous mode globally for running asynchronous functions synchronously.</p> </li> <li> <p>run_sync(func): Wrapper function that runs an asynchronous function synchronously. It takes an  asynchronous function as input and returns a wrapped function that can be called synchronously.</p> </li> <li> <p>as_sync_gen(gen): Utility to convert an asynchronous generator into a synchronous generator. It  yields items produced by the asynchronous generator in a synchronous manner.</p> </li> <li> <p>proxy(func): Decorator to run an asynchronous function synchronously if sync mode is enabled. It wraps  the asynchronous function, allowing it to be called synchronously when the sync mode is enabled.</p> </li> </ul> <p>Here is an example of how to write synchronous code:</p> <pre><code>import io\nimport mongotoy\n\n# Enable synchronous mode\nmongotoy.enable_sync_mode()\n\n# Open db session\nwith engine.session as session:\n    # Upload person image\n    person.image = session.fs().create('profile.jpeg', src=open('profile.jpeg'))\n\n    # Save person\n    session.save(person)\n\n    # Download person image\n    image = io.BytesIO\n    person.image.download_to(session.fs(), dest=image)\n\n    # Delete person image\n    person.image.delete()\n\n    # Delete person\n    session.delete(person)\n</code></pre> <p>Note</p> <p>Bear in mind that although the code may appear synchronous, it actually functions asynchronously behind the scenes. Mongotoy still relies on the asynchronous Motor driver for database interactions. The <code>mongotoy.sync</code> module simply  provides an abstraction layer for executing operations in a synchronous fashion.</p>"}]}