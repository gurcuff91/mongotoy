{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mongotoy","text":"<p> Async ODM for MongoDB. </p> <p> </p> <p> Mongotoy is a comprehensive asynchronous Object-Document Mapper (ODM) designed to simplify interactions    with MongoDB databases in Python applications. Leveraging the Motor asynchronous MongoDB driver, Mongotoy    seamlessly integrates asynchronous programming with MongoDB, providing developers with a powerful toolset for    building high-performance applications. This integration allows for efficient communication with MongoDB databases,   ensuring optimal scalability and responsiveness. With Mongotoy, developers can harness the full potential of    MongoDB's features while enjoying the benefits of asynchronous programming, making it an ideal choice for modern,    data-driven applications </p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Asynchronous Power: Mongotoy leverages the asynchronous paradigm of Python, enabling efficient management of I/O operations for optimal performance and responsiveness in applications.</p> </li> <li> <p>Based on Motor Driver: Mongotoy is built on top of the asynchronous Motor MongoDB driver, ensuring seamless  integration with asynchronous Python applications. </p> </li> <li> <p>Schemaless Flexibility: With a schemaless design, Mongotoy empowers developers to work with MongoDB databases without rigid schemas, adapting to evolving data models effortlessly.</p> </li> <li> <p>Intuitive API: Mongotoy features an elegant and straightforward API facilitating common database operations.</p> </li> <li> <p>Flexible Configuration Options: Mongotoy offers extensive configuration options at both the database and  document levels, enabling fine-tuning of MongoDB interactions for optimal performance and reliability.</p> </li> <li> <p>Custom Data Types Support: Mongotoy simplifies handling of custom data types and allows defining new types through Data Mapper classes, enhancing data integrity and consistency.</p> </li> <li> <p>Object-Document Mapping: Simplifying MongoDB document manipulation, Mongotoy maps Python objects to MongoDB  documents seamlessly, enabling intuitive and object-oriented interactions.</p> </li> <li> <p>Document Serialization: Mongotoy supports serialization of documents into JSON, BSON, or Python dictionaries,  enabling seamless integration with different parts of an application stack.</p> </li> <li> <p>Document Inheritance Support: Mongotoy provides robust support for document inheritance, enabling the creation of hierarchical data models and promoting code reuse and maintainability.</p> </li> <li> <p>Python Type Hint Support: Mongotoy allows developers to define document fields using Python type hints,  enhancing code readability and enabling type checking.</p> </li> <li> <p>Relationship Management: Simplifying relationship management between documents, Mongotoy offers robust support for references and embedded documents, automating insertions, deletions, and updates.</p> </li> <li> <p>Automatic Operation Handling: Mongotoy automates insertion and deletion management, ensuring data integrity  and consistency across related documents.</p> </li> <li> <p>Query Building: Mongotoy provides a powerful query building interface for constructing complex queries using  Pythonic syntax.</p> </li> <li> <p>Index Management: Mongotoy simplifies the management of database indexes, optimizing query performance for  efficient data retrieval.</p> </li> <li> <p>Transactions: Supporting MongoDB transactions, Mongotoy ensures data consistency and atomicity across multiple operations within a single transactional context.</p> </li> <li> <p>Geospatial Data Support: Mongotoy offers robust support for geospatial data types, facilitating storage,  querying, and spatial analysis.</p> </li> <li> <p>Database Seeding Management: With built-in support for database seeding, Mongotoy streamlines the  initialization of databases with predefined data sets, enhancing developer productivity.</p> </li> <li> <p>Support for Capped Collections: Mongotoy natively supports capped collections in MongoDB, ideal for  scenarios requiring fixed-size, ordered datasets.</p> </li> <li> <p>Time Series Collections Management: Mongotoy provides robust support for managing time series data in  MongoDB, optimized for storing and querying time-stamped data points.</p> </li> <li> <p>GridFS File Handling: Mongotoy seamlessly integrates with MongoDB's GridFS storage system for efficient handling of large files, offering a high-level interface for file management within MongoDB.</p> </li> </ul>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Let's begin with a minimal example by defining a document and performing CRUD operations on the database.</p> <pre><code>import asyncio\nfrom mongotoy import Document, Engine\nimport datetime\n\n\nclass Person(Document):\n    name: str\n    last_name: str\n    dob: datetime.date\n\n\n# Create database engine\ndb = Engine('test-db')\n\n\nasync def main():\n    # Create a new Person instance\n    person = Person(\n        name='John',\n        last_name='Doe',\n        dob=datetime.date(1990, 12, 25)\n    )    \n\n    # Connect to the MongoDB database\n    await db.connect('mongodb://localhost:27017')\n\n    # Open a database session\n    async with db.session() as session:\n\n        # Save the person to the database\n        await session.save(person)\n\n        # Fetch all persons from database\n        async for c in session.objects(Person):\n            print(c.dump_dict())\n\n        # Update person dob\n        person.dob=datetime.date(1995, 10, 25)\n        await session.save(person)\n\n        # Delete person from database\n        await session.delete(person)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#installing","title":"Installing","text":"<p>To install, just run:  <pre><code>pip install mongotoy\n</code></pre></p> <p>Or, if using poetry:</p> <pre><code>poetry add mongotoy\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the Apache 2.0 license.</p> <p>Some title</p> <p>Some content</p> <p>Some title</p> <p>Some content</p> <p>Danger</p> <p>Some content</p> <p></p>"},{"location":"documents/","title":"Documents","text":""},{"location":"documents/#embedded-documents","title":"Embedded Documents","text":"<p>An embedded document serves as a container for defining complex object types that are nested within other  documents. Unlike standalone documents, embedded documents do not represent individual collections in the database.  Instead, they are used to encapsulate related data fields within a parent document, allowing for more structured and  organized data models.</p> <p>Mongotoy supports the creation of embedded documents by inheriting from <code>mongotoy.EmbeddedDocument</code> and defining your  class attributes in a manner similar to how you would define a Python dataclass. Here's a quick example:</p> <pre><code>from mongotoy import EmbeddedDocument\n\n\nclass Address(EmbeddedDocument):\n    street: str\n    city: str\n    zipcode: int\n    country: str\n</code></pre>"},{"location":"documents/#documents","title":"Documents","text":"<p>Defining documents in Mongotoy is straightforward. Simply inherit from <code>mongotoy.Document</code> class and define your class attributes similarly to how you would define a Python dataclass.  In this example, each class attribute represents a field in the database, and the class itself corresponds  to a collection:</p> <pre><code>import datetime\nfrom mongotoy import Document\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n</code></pre> <p>By default, Mongotoy pluralizes the lowercase class name to determine the collection name. So, in this  case, the collection name will be <code>persons</code>. </p> <p>Additionally, you can specify a custom collection name by defining the <code>__collection_name__</code> property within the class:</p> <pre><code>from mongotoy import Document\n\n\nclass Person(Document):\n    __collection_name__ = 'users'\n</code></pre> <p>Attention</p> <p>When defining class attributes, it's crucial to specify their types. Mongotoy utilizes these type annotations  to generate fields accordingly. Attributes without type annotations will be ignored and treated as regular class fields.</p>"},{"location":"documents/#the-id-field","title":"The id field","text":"<p>In Mongotoy, the <code>id</code> field is essential in every document, acting as the primary key to ensure unique identification.  You can define the id field using the <code>mongotoy.field()</code> function, as explained in the  fields section. If you create a new document without explicitly specifying an <code>id</code> field, Mongotoy automatically generates one and assigns a <code>bson.ObjectId</code> type to it.  This unique identifier simplifies document management and facilitates efficient querying within MongoDB collections.</p> <p>Note</p> <p>All classes derived from <code>mongotoy.Document</code> come with an <code>id</code> property, which provides access to the document's ID  field. To retrieve the ID field of a <code>Person</code> document, simply access it using <code>Person.id</code>. Similarly, to access the ID field value of a <code>Person</code> instance, use <code>person.id</code>.</p>"},{"location":"documents/#configuration","title":"Configuration","text":"<p>Mongotoy offers document-level configuration for various settings, including indexes, capped collection options,  timeseries collection options, codec options, read preference, read concern, write concern, and additional  MongoDB document options.</p> <p>Configuration params:</p> <ul> <li>indexes: List of indexes for the document.</li> <li>capped: Indicates if the collection is capped (default is False).</li> <li>capped_size: The maximum size of the capped collection in bytes (default is 16 MB).</li> <li>capped_max: The maximum number of documents allowed in a capped collection (default is None).</li> <li>timeseries_field: The field name to use as the time field for timeseries collections (default is None).</li> <li>timeseries_meta_field: The field name for metadata in timeseries collections (default is None).</li> <li>timeseries_granularity: The granularity of time intervals.</li> <li>timeseries_expire_after_seconds: The expiration time for documents in a timeseries collection, in seconds.</li> <li>codec_options: The BSON codec options (default is None).</li> <li>read_preference: The read preference for the document (default is None).</li> <li>read_concern: The read concern for the document (default is None).</li> <li>write_concern: The write concern for the document (default is None).</li> <li>extra_options: Extra options for the document configuration (default is an empty dictionary).</li> </ul> <p>All of these configurations apply only at the document collection level and do not affect the rest of the  database collections.</p>"},{"location":"documents/#supported-data-types","title":"Supported Data Types","text":"<p>Mongotoy supports a wide range of data types, encompassing both common built-in Python types and custom types  tailored to specific use cases. </p>"},{"location":"documents/#supported-built-in-python-types","title":"Supported built-in Python types","text":"<ul> <li><code>str</code></li> <li><code>bool</code></li> <li><code>bytes</code></li> <li><code>int</code></li> <li><code>float</code></li> <li><code>decimal.Decimal</code></li> <li><code>datetime.datetime</code></li> <li><code>datetime.date</code></li> <li><code>datetime.time</code></li> <li><code>uuid.UUID</code></li> </ul>"},{"location":"documents/#supported-bson-types","title":"Supported bson types","text":"<ul> <li><code>bson.ObjectId</code></li> </ul>"},{"location":"documents/#supported-sequence-types","title":"Supported sequence types","text":"<ul> <li><code>list</code></li> <li><code>tuple</code></li> <li><code>set</code></li> </ul>"},{"location":"documents/#supported-custom-types","title":"Supported custom types","text":"<ul> <li><code>mogotoy.types.IpV4</code>: Represents an IPv4 address.</li> <li><code>mogotoy.types.IpV6</code>: Represents an IPv6 address.</li> <li><code>mogotoy.types.Port</code>: Represents a port number.</li> <li><code>mogotoy.types.Mac</code>: Represents a MAC address.</li> <li><code>mogotoy.types.Phone</code>: Represents a phone number.</li> <li><code>mogotoy.types.Email</code>: Represents an email address.</li> <li><code>mogotoy.types.Card</code>: Represents a credit card number.</li> <li><code>mogotoy.types.Ssn</code>: Represents a Social Security Number (SSN).</li> <li><code>mogotoy.types.Hashtag</code>: Represents a hashtag.</li> <li><code>mogotoy.types.Doi</code>: Represents a Digital Object Identifier (DOI).</li> <li><code>mogotoy.types.Url</code>: Represents a URL.</li> <li><code>mogotoy.types.Version</code>: Represents a Semantic Version Number.</li> <li><code>mogotoy.types.Point</code>: Represents a GEO-JSON Point.</li> <li><code>mogotoy.types.MultiPoint</code>: Represents a GEO-JSON MultiPoint.</li> <li><code>mogotoy.types.LineString</code>: Represents a GEO-JSON LineString.</li> <li><code>mogotoy.types.MultiLineString</code>: Represents a GEO-JSON MultiLineString.</li> <li><code>mogotoy.types.Polygon</code>: Represents a GEO-JSON Polygon.</li> <li><code>mogotoy.types.MultiPolygon</code>: Represents a GEO-JSON MultiPolygon.</li> <li><code>mogotoy.types.Json</code>: Represents a valid json data.</li> <li><code>mogotoy.types.Bson</code>: Represents a valid bson data.</li> <li><code>mogotoy.types.File</code>: Represents a Grid-FS object.</li> </ul> <p>You can effortlessly utilize these data types within your documents, and Mongotoy will take care of automatic  field creation and validation.</p>"},{"location":"documents/#using-nullable-types","title":"Using Nullable types","text":"<p>By default, Mongotoy does not permit <code>null</code> data. However, you can specify nullability using <code>typing.Optional</code>.  Below is an example of a Person document that allows <code>null</code> data:</p> <pre><code>import datetime\nfrom typing import Optional\nfrom mongotoy import Document\n\n\nclass Person(Document):\n    name: Optional[str]\n    age: Optional[int]\n    dob: Optional[datetime.datetime]\n</code></pre>"},{"location":"documents/#using-documents-types","title":"Using Documents types","text":"<p>Mongotoy facilitates the integration of other documents as types within documents, offering a flexible approach  to defining complex data structures. This means you can use instances of other Mongotoy document classes as  attribute types within your own document classes. By incorporating related documents as types, you can establish  meaningful relationships between different data entities, enhancing the organization and clarity of your data model.  This feature enables you to design more comprehensive and interconnected schemas, reflecting the real-world  relationships between entities in your application domain.</p> <p>Note</p> <p>There are two types of documents: <code>mongotoy.Document</code> and <code>mongotoy.EmbeddedDocument</code>.  While you can use both types seamlessly in your application, it's essential to understand that Mongotoy employs  different approaches under the hood to handle them.</p> <p>When you specify a document field with a <code>mongotoy.EmbeddedDocument</code>, Mongotoy treats it as embedded data,  meaning that the document is stored directly within the parent document. On the other hand, when you use a <code>mongotoy.Document</code>, Mongotoy treats it as a reference to another collection. See references section</p> <p>Here's an example of embedding an address within a person document:</p> <pre><code>import datetime\nfrom mongotoy import Document, EmbeddedDocument\n\nclass Address(EmbeddedDocument):\n    street: str\n    city: str\n    zipcode: int\n    country: str\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n    address: Address\n</code></pre> <p>Here's an example of referencing an address within a person document:</p> <pre><code>import datetime\nfrom mongotoy import Document\n\nclass Address(Document):\n    street: str\n    city: str\n    zipcode: int\n    country: str\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n    address: Address\n</code></pre> <p>Note</p> <p>The only difference is the base class of the <code>Address</code> document.</p>"},{"location":"documents/#forwarding-types","title":"Forwarding Types","text":"<p>Mongotoy facilitates the utilization of document types as forward dependencies,  enabling the use of document types that may not have been created yet or are defined in different modules. This feature supports self-referential document type as well.</p> <p>Here's an example demonstrating the use of a self-referential document type:</p> <pre><code>import datetime\nfrom typing import Optional\nfrom mongotoy import Document, reference\n\n\nclass Person(Document):\n    name: str\n    age: int\n    dob: datetime.datetime\n    parent: Optional['Person'] = reference()\n</code></pre> <p>In this example, the <code>Person</code> document references its own type in the <code>parent</code> field, allowing for self-referential  relationships within the document.</p> <p>Warning</p> <p>Using <code>mongotoy.reference(</code>) is essential for specifying the <code>parent</code> field as a reference, especially when dealing  with Forwarding Types. Mongotoy doesn't evaluate Forwarding Types during document creation to determine their type.  By default, it assumes they are embedded documents. Therefore, <code>mongotoy.reference()</code> ensures proper handling of the  field as a reference. See references section.</p>"},{"location":"documents/#fields","title":"Fields","text":"<p>Mongotoy not only generates fields based on types but also provides options for customization such as  aliases, indexing, uniqueness, and default values using the <code>mongotoy.field()</code> function. This enables you to define fields with specific properties tailored to the application needs, offering enhanced control and flexibility in document definition.</p>"},{"location":"documents/#customization-parameters","title":"Customization Parameters","text":"<p>The <code>mongotoy.field()</code> function accepts the following parameters:</p> <ul> <li>alias: Alias for the field. Defaults to None.</li> <li>id_field: Indicates if the field is an ID field. Defaults to False.</li> <li>default: Default value for the field. Defaults to <code>mongotoy.expresions.EmptyValue</code>.</li> <li>default_factory: Factory function for generating default values. Defaults to None.</li> <li>index: Type of index for the field. Defaults to None.</li> <li>sparse: Whether the index should be sparse. Defaults to False.</li> <li>unique: Whether the index should be unique. Defaults to False.</li> </ul> <p>Here's an example that showcases the customization of fields in Mongotoy documents.  Each field in the <code>Person</code> class utilizes the <code>mongotoy.field()</code> function for customization.</p> <pre><code>import pymongo\nimport datetime\nfrom mongotoy import Document, field\n\n\nclass Person(Document):\n    code: str = field(id_field=True)\n    name: str = field(index=pymongo.TEXT, unique=True)\n    age: int = field(index=pymongo.DESCENDING)\n    dob: datetime.datetime = field(default_factory=datetime.date.today)\n</code></pre> <p>The <code>code</code> field is specified with <code>id_field=True</code>, indicating it serves as the primary key.  Additionally, the <code>name</code> field is configured for full-text search indexing (<code>index=pymongo.TEXT</code>) and uniqueness (<code>unique=True</code>). The <code>age</code> field is indexed in descending order (<code>index=pymongo.DESCENDING</code>), facilitating  efficient sorting based on age. Lastly, the <code>dob</code> field is assigned a default value using  <code>default_factory=datetime.date.today</code>, ensuring it defaults to the current date if not explicitly provided.</p>"},{"location":"documents/#references","title":"References","text":"<p>Mongotoy simplifies the handling of references by automatically generating them when you use a <code>mongotoy.Document</code>  type as a field in another document. This means that you don't need to manually manage references between documents.  Additionally, Mongotoy provides flexibility in configuring reference behavior through the <code>mongotoy.reference()</code>  function. With this function, you can customize how references are handled.</p>"},{"location":"documents/#customization-parameters_1","title":"Customization Parameters","text":"<p>The <code>mongotoy.reference()</code> function accepts the following parameters:</p> <ul> <li>ref_field: Name of the referenced field. Defaults to <code>id</code></li> <li>key_name: Key name for the reference. Defaults to None.</li> </ul> <p>Note</p> <p>If <code>key_name</code> isn't specified, Mongotoy automatically generates it by concatenating the name of the field that holds the reference value with the name of the referenced field.</p> <p>Here's an example that showcases the customization of references in Mongotoy documents. </p> <pre><code>import datetime\nfrom typing import Optional\nfrom mongotoy import Document, reference\n\n\nclass Person(Document):\n    code: str\n    name: str\n    age: int\n    dob: datetime.datetime\n    parent: Optional['Person'] = reference(ref_field='code', key_name='p_code')\n</code></pre> <p>The <code>parent</code> field in the <code>Person</code> document class serves as a reference to another <code>Person</code> document,  denoting the individual's parent. This field is optional, enabling it to either reference another <code>Person</code>  document or set as null. Through the <code>mongotoy.reference()</code> function, the reference behavior is established based on the <code>code</code> field of the referenced document. In the database, the reference key is labeled as <code>p_code</code>.  This setup ensures that when a <code>Person</code> document is saved, the <code>code</code> value of the referenced <code>Person</code> document  stored in the <code>parent</code> field is also stored in the current document under the <code>p_code</code> key.</p> <p>Danger</p> <p>Utilizing <code>mongotoy.reference()</code> in a class that isn't derived from <code>mongotoy.Document</code>, or  omitting <code>mongotoy.reference()</code> when using a <code>mongotoy.Document</code> based class as a forwarded type, will result in a <code>mongotoy.errors.DocumentValidation</code> error during document instantiation.</p> <p>Mongotoy streamlines the definition of MongoDB document structures by offering a user-friendly interface that leverages Python syntax and type annotations. This approach allows you to easily define field types and establish relationships between documents, facilitating the creation of data models. With Mongotoy, you can seamlessly  navigate the complexities of MongoDB schema design, ensuring a more intuitive and efficient development process.</p>"}]}